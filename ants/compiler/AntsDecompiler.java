package ants.compiler;

import java.io.*;
import java.util.*;

import ants.vm.AntClass;
import ants.vm.AntsVm;
import ants.vm.Instruction;

/**
 * The <code>AntsDecompiler</code> class provides the decompiler of the Ants
 * system.  It translates binary ant files (created by {@link AntsCompiler}
 * back to source files.  Variables and labels are translated to generic names
 * of the form "$Vxxx" and "%Lxxx".
 */
public class AntsDecompiler {

    /**
     * Instruction identifiers.
     */
    public static final String[] instructions = AntsCompiler.instructions;

    /**
     * Direction constant identifiers.
     */
    public static String[] directions = AntsCompiler.directions;

    /**
     * Tribe constant identifiers,
     */
    public static String[] tribes = AntsCompiler.tribes;

    /**
     * The output writer.
     */
    protected PrintWriter out;

    /**
     * The ant class to be decompiled.
     */
    protected AntClass ant;

    /**
     * The set of labels in the program.  Each label is stored as a
     * <code>Short</code> object representing the address of the label, so
     * that this set is sorted by address.
     */
    protected SortedSet<Short> labels;

    /**
     * The program of the ant class to be decompiled.
     */
    protected short[] program;

    /**
     * The opcode of the current instruction.
     */
    protected short opcode;

    /**
     * The result code of the current instruction.
     */
    protected short result;

    /**
     * The code of the first operand of the current instruction.
     */
    protected short op1;

    /**
     * The code of the second operand of the current instruction.
     */
    protected short op2;

    /**
     * Returns the opcode of an instruction.
     *
     * @param pc The address of the instruction.
     * @return The opcode of the instruction at the given address.
     */
    protected short getInstruction(short pc) {
        return program[AntsVm.INSTRUCTION_SIZE * pc + AntsVm.OPCODE_OFFSET];
    }

    /**
     * Returns the code of the first operand of an instruction.
     *
     * @param pc The address of the instruction.
     * @return The code of the first operand of the instruction at the
     *         given address.
     */
    protected short getOperand1(short pc) {
        return program[AntsVm.INSTRUCTION_SIZE * pc + AntsVm.OP1_OFFSET];
    }

    /**
     * Returns the code of the second operand of an instruction.
     *
     * @param pc The address of the instruction.
     * @return The code of the second operand of the instruction at the
     *         given address.
     */
    protected short getOperand2(short pc) {
        return program[AntsVm.INSTRUCTION_SIZE * pc + AntsVm.OP2_OFFSET];
    }

    /**
     * Returns the code of the result of an instruction.
     *
     * @param pc The address of the instruction.
     * @return The code of the result of the instruction at the
     *         given address.
     */
    protected short getResult(short pc) {
        return program[AntsVm.INSTRUCTION_SIZE * pc + AntsVm.RESULT_OFFSET];
    }

    /**
     * Creates the set of labels from the program.
     */
    protected void createLabels() {

        for (short pc = 0; pc < ant.getProgramSize(); pc++) {

            short opc = (short)
                (getInstruction(pc) & ~AntsVm.OP1_CONSTANT & ~AntsVm.OP2_CONSTANT);

            if (opc == Instruction.GOTO || opc == Instruction.GOTO_IF) {
                short addr = getOperand1(pc);
                labels.add(addr);
            }
        }
    }

    /**
     * Writes the header of the ant file.
     */
    protected void writeHeader() {

        out.println(";");
        out.println("; Generated by the Ants Decompiler");
        out.println(";");
        out.println("; " + ant.getProgramSize() + " instructions");
        out.println("; " + ant.getVariableSize() + " variables");
        out.println(";");
        out.println();
        out.println("DefineAnt " + ant.getName() + "(" + ant.getId() + "):");
        out.println();
        out.println("Configuration:");
        out.println();
        out.println("    $MyBackpackSize = " + ant.getBackpackSize());
        out.println();
        out.println("Program:");
        out.println();
    }

    /**
     * Prints the value at a given offset as a variable.
     *
     * @param offset The byte offset from the start of the current
     *               instruction.
     */
    protected void printVariable(int offset) {

        short var;

        if (offset == AntsVm.OP1_OFFSET)
            var = op1;
        else if (offset == AntsVm.OP2_OFFSET)
            var = op2;
        else
            var = result;

        out.print("$V" + var);
    }

    /**
     * Prints the value at a given offset as a label.
     *
     * @param offset The byte offset from the start of the current
     *               instruction.
     */
    protected void printLabel(int offset) {

        short addr;

        if (offset == AntsVm.OP1_OFFSET)
            addr = op1;
        else if (offset == AntsVm.OP2_OFFSET)
            addr = op2;
        else
            addr = result;

        out.print("%L" + addr);
    }

    /**
     * Prints the value at a given offset as a number literal.
     *
     * @param offset The byte offset from the start of the current
     *               instruction.
     */
    protected void printNumber(int offset) {

        short val;

        if (offset == AntsVm.OP1_OFFSET)
            val = op1;
        else if (offset == AntsVm.OP2_OFFSET)
            val = op2;
        else
            val = result;

        out.print(val);
    }

    /**
     * Prints the value at a given offset.  This value can be either a
     * variable or a number.
     *
     * @param offset The byte offset from the start of the current
     *               instruction.
     */
    protected void printValue(int offset) {

        if (offset == AntsVm.OP1_OFFSET && (opcode & AntsVm.OP1_CONSTANT) != 0 ||
            offset == AntsVm.OP2_OFFSET && (opcode & AntsVm.OP2_CONSTANT) != 0)
            printNumber(offset);
        else
            printVariable(offset);
    }

    /**
     * Prints the value at a given offset as a direction constant.
     *
     * @param offset The byte offset from the start of the current
     *               instruction.
     */
    protected void printDirection(int offset) {

        if (offset == AntsVm.OP1_OFFSET && (opcode & AntsVm.OP1_CONSTANT) != 0 ||
            offset == AntsVm.OP2_OFFSET && (opcode & AntsVm.OP2_CONSTANT) != 0) {

            short dir;

            switch (offset) {
                case AntsVm.OP1_OFFSET: dir = op1; break;
                case AntsVm.OP2_OFFSET: dir = op2; break;
                default: dir = result;
            }

            if (dir > directions.length)
                dir = 0;

            out.print("#" + directions[dir]);

        } else {
            printVariable(offset);
        }
    }

    /**
     * Prints the value at a given offset as a tribe constant.
     *
     * @param offset The byte offset from the start of the current
     *               instruction.
     */
    protected void printTribe(int offset) {

        if (offset == AntsVm.OP1_OFFSET && (opcode & AntsVm.OP1_CONSTANT) != 0 ||
            offset == AntsVm.OP2_OFFSET && (opcode & AntsVm.OP2_CONSTANT) != 0) {

            short tribe;

            switch (offset) {
                case AntsVm.OP1_OFFSET: tribe = op1; break;
                case AntsVm.OP2_OFFSET: tribe = op2; break;
                default: tribe = result;
            }

            if (tribe > tribes.length)
                tribe = 0;

            out.print("#" + tribes[tribe]);

        } else {
            printVariable(offset);
        }
    }

    /**
     * Writes the program of the ant class to the output writer.
     */
    protected void writeProgram() {

        Iterator<Short> labelIt = labels.iterator();
        short currentLabel = -1;

        if (labelIt.hasNext())
            currentLabel = labelIt.next();

        for (short pc = 0; pc < ant.getProgramSize(); pc++) {

            if (pc == currentLabel) {
                out.println("%L" + pc + ":");
                if (labelIt.hasNext())
                    currentLabel = labelIt.next();
            }

            opcode = getInstruction(pc);
            result = getResult(pc);
            op1 = getOperand1(pc);
            op2 = getOperand2(pc);

            short icode = (short)
                (opcode & ~AntsVm.OP1_CONSTANT & ~AntsVm.OP2_CONSTANT);

            out.print("    " + instructions[icode] + "(");

            switch (icode) {

                case Instruction.MAKE_ANT:
                    printValue(AntsVm.OP1_OFFSET);
                    break;

                case Instruction.STONES:
                case Instruction.OBSTACLES:
                case Instruction.FOOD:
                case Instruction.FOOD_AMOUNT:
                case Instruction.STONE_NUMBER:
                case Instruction.MOVE:
                    printDirection(AntsVm.OP1_OFFSET); out.print(", ");
                    printVariable(AntsVm.RESULT_OFFSET);
                    break;

                case Instruction.ANTS:
                case Instruction.MARKS:
                case Instruction.MARK_VALUE:
                    printDirection(AntsVm.OP1_OFFSET); out.print(", ");
                    printTribe(AntsVm.OP2_OFFSET); out.print(", ");
                    printVariable(AntsVm.RESULT_OFFSET);
                    break;

                case Instruction.GET_FOOD:
                case Instruction.PUT_FOOD:
                case Instruction.GET_STONES:
                case Instruction.PUT_STONES:
                    printDirection(AntsVm.OP1_OFFSET); out.print(", ");
                    printValue(AntsVm.OP2_OFFSET); out.print(", ");
                    printVariable(AntsVm.RESULT_OFFSET);
                    break;

                case Instruction.SET_MARK:
                    printDirection(AntsVm.OP1_OFFSET); out.print(", ");
                    printValue(AntsVm.OP2_OFFSET); out.print(", ");
                    break;

                case Instruction.CLEAR_MARK:
                    printDirection(AntsVm.OP1_OFFSET);
                    break;

                case Instruction.COPY:
                case Instruction.NOT:
                case Instruction.BITS_TRUE:
                case Instruction.BITS_FALSE:
                case Instruction.NEG:
                    printValue(AntsVm.OP1_OFFSET); out.print(", ");
                    printVariable(AntsVm.RESULT_OFFSET);
                    break;

                case Instruction.OR:
                case Instruction.AND:
                case Instruction.XOR:
                case Instruction.ADD:
                case Instruction.SUB:
                case Instruction.MULT:
                case Instruction.DIV:
                case Instruction.EQUAL:
                case Instruction.NOT_EQUAL:
                case Instruction.LESS:
                case Instruction.LESS_EQUAL:
                case Instruction.GREATER:
                case Instruction.GREATER_EQUAL:
                    printValue(AntsVm.OP1_OFFSET); out.print(", ");
                    printValue(AntsVm.OP2_OFFSET); out.print(", ");
                    printVariable(AntsVm.RESULT_OFFSET);
                    break;

                case Instruction.GOTO:
                    printLabel(AntsVm.OP1_OFFSET);
                    break;

                case Instruction.GOTO_IF:
                    printLabel(AntsVm.OP1_OFFSET); out.print(", ");
                    printValue(AntsVm.OP2_OFFSET);
                    break;

                default:
                    // Do nothing.
            }

            out.println(")");
        }
    }

    /**
     * The main method of the Ants decompiler.
     *
     * @param args An array of paths to the binary ant files to be
     *             decompiled.
     */
    public static void main(String[] args) {

        if (args.length < 1) {
            System.out.println(
                "Usage: java ants.compiler.AntsDecompiler [bin files ...]");
        } else {

            for (int i = 0; i < args.length; i++) {

                System.out.println("Decompiling " + args[i]);

                AntClass ant;

                try (FileInputStream fis = new FileInputStream(args[i]);
                     ObjectInputStream ois = new ObjectInputStream(fis)) {

                    ant = (AntClass) ois.readObject();

                } catch (ClassNotFoundException e) {
                    System.out.println(
                            "Error while opening or reading input file: " +
                            e.getMessage());
                    continue;

                } catch (IOException e) {
                    System.out.println(
                            "Error while opening or reading input file: " +
                            e.getMessage());
                    continue;
                }

                try (FileWriter srcWriter = new FileWriter(args[i] + ".dec")) {

                    AntsDecompiler decompiler = new AntsDecompiler();
                    decompiler.decompile(ant, srcWriter);

                } catch (IOException e) {
                    System.out.println(
                            "Error while writing output file: " +
                            e.getMessage());
                    continue;
                }
            }
        }
    }

    /**
     * Decompiles an ant class and writes the source text to a writer.
     *
     * @param ant The ant class to decompile.
     * @param w The writer where to write the output to.
     */
    public void decompile(AntClass ant, Writer w) {

        this.out     = new PrintWriter(w);
        this.ant     = ant;
        this.program = ant.getProgram();
        this.labels  = new TreeSet<>();

        createLabels();
        writeHeader();
        writeProgram();

        this.out.close();
    }
}
